The term project for T\+T\+K4155 Industrielle og innbygde datasystemers konstruksjon for group 20 2016.

Created by Sondre Wangenstein BaugstÃ¸, Johan Lofstad and Sondre Vincent Russvoll.

\subsection*{File structure}

The library is shared between the two nodes, and it can be found in the lib folder. Every class has its own folder, with its own .h and .cpp file.

If a library is specific to one chip, for example the A\+Tmega162, we have included a {\ttfamily \#ifdef \+\_\+\+\_\+\+A\+V\+R\+\_\+\+A\+Tmega162\+\_\+\+\_\+} in the header file. This define is set by the compiler during the build process.

The node specific code is located in the node(1/2) / src. The {\itshape init.\+cpp} file is ran each time the M\+CU starts, and {\itshape main.\+cpp} is the main file. The {\itshape state\+\_\+machine.\+cpp} is the state machine implementation.

\subsubsection*{State machine}

We have made a state machine for each of the nodes, and is implemented in lib/state\+\_\+machine. Under {\itshape node(1/2) / src / state\+\_\+machine.\+cpp} we have specified and implemented the states of the node.

There is one function that runs when a state is entered, one that loops until the state is left, and one that runs when we leave the state. You transition between states by calling {\ttfamily fsm-\/$>$Transition(\+S\+T\+A\+T\+E\+\_\+\+N\+E\+X\+T, 0)}

{\bfseries Advantages of using this F\+SM}

There are several advantages of using this kind of F\+SM. Adding and removing states is very easy, and only requires you to add/remove a function from an array. The system is always in a defined state, giving less room for unexpected behavior. The code is also very easy to read, making it easy to identify every state and what it does.

{\bfseries Shared resources}

Since enter, loop and leave are different functions, they all have their own separate scope. This causes us to have a few global variables. This is not a big problem due to putting those variable in a namespace, making them local to the file. \subsection*{Extras}

We have implemented a few extra features, listed underneath.

\subsubsection*{Toolchain and C++}

We decided to create our own toolchain, and not use the supplied toolchain in A\+T\+M\+EL Studio. All of our development is done in Linux (except for the G\+AL), and we used \href{http://www.nongnu.org/avrdude/}{\tt A\+V\+R\+D\+U\+DE}, \href{http://www.nongnu.org/avr-libc/}{\tt A\+V\+R-\/\+G++} and \href{https://cmake.org/}{\tt C\+Make} to build and flash the code onto the A\+T\+Mega.

In stead of using C, we decided to go for C++. So, every module is built as a class, with most of them having a singleton implementation.

We used the \href{https://help.ubuntu.com/community/Minicom}{\tt minicom} software to read \hyperlink{class_u_a_r_t}{U\+A\+RT} messages.

\subsubsection*{Extended memory map}

The memory map has been extended from 2\+KB of S\+R\+AM to 8\+KB of S\+R\+AM by not using the J\+T\+AG interface that occupied those pins. This gave us a memory map as seen below.



\subsubsection*{\hyperlink{namespace_highscore}{Highscore}, n\+R\+F51 chip and Bluetooth}

We have implemented a highscore system that stores the highscore in the E\+E\+P\+R\+OM at the A\+Tmega162. The highscore system is based on time, and the longer you play the higher score you get. This is realized through a timer module in the A\+Tmega2560.

When a game ends, you are prompted to enter your name. You enter this name by using an android app we have developed, which communicates with a n\+R\+F51 (from now on node 3) dev board through B\+LE (Bluetooth Low Energy).

When node 3 receives the name, it is sent to node 2 through \hyperlink{namespace_s_p_i}{S\+PI}. Node 2 then sends the name to node 1, which stores the name in the E\+E\+P\+R\+OM if the highscore is good enough.

This highscore can later be found by the menu entry \char`\"{}\+Highscore\char`\"{}. You can also clear the highscore here through the menu entry clear.

{\bfseries You can find the code for the n\+R\+F51 chip and the android code in the extra folder.}

\subsubsection*{Render \hyperlink{class_o_l_e_d}{O\+L\+ED} from Node 2 over \hyperlink{class_c_a_n}{C\+AN}}

It is possible to render the \hyperlink{class_o_l_e_d}{O\+L\+ED} from node 2 through the \hyperlink{class_c_a_n}{C\+AN} network. At the moment, it does not render fast enough for it to be a viable option, but we have included a menu entry which illustrates that it is possible.

This is done through the \hyperlink{class_s_c_p}{S\+CP} protocol that we developed for this project. Please see the documentation and the \hyperlink{class_s_c_p}{S\+CP} class. We send a \hyperlink{class_c_a_n}{C\+AN} message with \hyperlink{class_s_c_p}{S\+CP} instruction node 1 to write to a specific memory address. The \hyperlink{class_o_l_e_d}{O\+L\+ED} addresses and data is calculated at node 2. 